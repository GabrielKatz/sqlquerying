\documentclass[12pt,a4paper]{report}

\setlength{\topmargin}{0 cm}
\usepackage{lmodern}
\usepackage{times}
\usepackage{float}
\usepackage{rotating}
\usepackage[german]{babel}
\usepackage{graphics}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{needspace}
\makeatletter
\newcommand{\lstuppercase}{\uppercase\expandafter{\expandafter\lst@token
                           \expandafter{\the\lst@token}}}
\newcommand{\lstlowercase}{\lowercase\expandafter{\expandafter\lst@token
                           \expandafter{\the\lst@token}}}
\makeatother
\lstdefinestyle{SQL}{basicstyle=\ttfamily,
                        keywordstyle=\lstuppercase,
                        emphstyle=\itshape,
                        showstringspaces=false,
                        numbers=left,
                        }
\lstset{style=SQL}                
\graphicspath{ {../img/} }
\usepackage[table,dvipsnames]{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{ntheorem}
\usepackage{pifont}
\theoremstyle{plain}
\theorembodyfont{\normalfont}
\newtheorem{exercise}{Aufgabe}[chapter]

\newtheorem{example}{Beispiel}[chapter]

\title{Relationale Datenabfragen mit SQL}
\author{Gabriel Katz}

\begin{document}
\maketitle
\tableofcontents
\chapter{Einleitung}

\section{Worum geht es hier?}
Eines der wichtigsten Zwecke von Computer ist die Speicherung von Daten. Wenn eine Menge von organisierten
Informationen dauerhaft auf einem zentralen Computer gespeichert werden, und diese Daten leicht abgefragt, 
erg\"{a}nzt, bearbeitet und gel\"{o}scht werden kann, ist von einer \textbf{Datenbank} die Rede. So ist zum Beispiel
ein Notizblock (egal ob in Papierform oder in digitaler, wie zum Beispiel Notes oder OneNote) eine stark 
eingeschr"ankte Datenbank. Um relevante Daten zu finden, muss man eventuell Seite f"ur Seite durchgehen. Beim 
Notizblock aus Papier ist auch die "Uberarbeitung der Daten eingeschr"ankt, da man z.B. auf der Seite nur begrenzt
Platz hat. Daher stellt sich die Frage, welche besser zum Bearbeiten geeigneten Wege es gibt, Daten auf dem Computer
zu speichern.

Die relationalen Datenbanken sind die wohl verbreitetste Art von Datenbanken. Zwar gibt es zur Zeit einen Trend zu anderen, sogenannten 
NoSQL-Datenbanken, doch auch f"ur diese sind Kenntnisse in relationalen Datenbanken wichtig.
Diese Unterlagen besch"aftigen sich mit SQL, der Standardsprache in relationalen Datenbanken.

Vom Leser dieser Unterlagen wird erwartet, dass er das Konzept relationaler Datenbanken bereits kennt, und bereits mit der Modellierung
von relationalen Datenbanken erste Erfahrungen gemacht hat. Somit sind diese Unterlagen sind besonders gut f"ur ein erstes Programmierlab 
nach der Einf"uhrung in die relationalen Datenbanken geeignet.

In diesem Kapitel repetieren wir anhand dreier Datenbankbeispielen, welche wir in den gesamten Unterlagen wieder verwenden werden, die relationalen 
Datenbanken. Leser, welche sich diese Repetition sparen m"ochten, k"onnen dies tun, wenn sie die Datenbankbeispiele verstanden haben.

Der Inhalt der weiteren Kapitel ist wie folgt aufgebaut: Kapitel 2 erkl"art, was
SQL ist, und zeigt, wie man eine Datenbank in SQL erstellt. In Kapitel 3 wird gezeigt, wie man Daten in SQL aus einer einzelnen Tabelle abfragt. 
Danach sehen wir in Kapitel 4, wie man Abfragen "uber mehrere Tabellen erstellen kann. Kapitel 5 beschreibt dann, wie mehrere Datens"atze in einem
Datensatz zusammengefasst werden k"onnen.

SQL verf"ugt "uber sehr viele Funktionen, um Berechnungen mit den internen Datentypen durchzuf"uhren. Beispielsweise gibt es eine
Funktionsbibliothek, um Zeitdaten zu vergleichen und zu berechnen. Da diese Unterlagen sich nicht als SQL-Referenz versteht, 
werden solche Funktionen nur dann eingef"uhrt, wenn sie verwendet werden.
\section{Repetition: Relationale Datenbanken}

Das Konzept f\"{u}r relationale Datenbanken basiert auf einem Paper von Dr. E. F. Codd aus dem Jahre 1970 
namens ``A Relational Model of Data for Large Shared Data Banks''. Dort schlug er vor, Daten in einer Menge von 
\textbf{Tabellen} darzustellen. Dies Tabellen haben einen Namen und mehrere \textbf{Spalten}. Eine Spalte einer 
Tabelle ist durch seinen Namen, seinen Datentyp, und ob sie obligatorisch oder fakultativ ist, definiert. Datentypen 
dr\"{u}cken aus, welche Art von Daten in der Spalte gespeichert werden kann. Beispielsweise hat eine Spalte, in 
welcher ein Datum gespeichert wird einen anderen Datentypen wie eine Spalte mit Zahl oder wie eine Spalte mit Text. 
Wir werden einige Datentypen, welche von SQL unterst"utzt werden im n\"{a}chsten Kapitel etwas mehr im Detail betrachten. \\
Die Daten werden 
dann in den \textbf{Zeilen} der Tabelle gespeichert. Jede Zeile der Tabelle enth\"{a}lt mindestens in allen 
obligatorischen Spalten Daten. Wenn eine Zeile in einer Spalte keine Daten hat, sagt man auch, dass sie \lstinline{NULL} enth"alt.
 Normalerweise ist die Anzahl der Spalten der Tabelle (des Datenschemas) 
\"{u}berschaubar, wogegen die Anzahl der Zeilen riesig sein kann. \\
Eine Tabelle in einer relationalen Datenbank hat immer ein Merkmal, an welchem die Zeilen der Tabellen eindeutig
identifiziert werden k"onnen. Dieses Merkmal wird \textbf{Prim\"arschl\"ussel (PK)} genannt. Dieser Prim\"arschl\"ussel 
besteht h\"aufig aus einer einzelnen Tabellenspalte, doch er kann auch aus mehreren Tabellenspalten bestehen.
In diesem Fall spricht man von einem \textbf{zusammengesetzten} Schl\"ussel. Keines der Tabellenspalten des Prim"arschl"ussels 
darf fakultativ sein.  H\"aufig ist der Prim\"arschl\"ussel eine
Spalte, welche nicht eigentliche Daten enth\"alt, sondern nur ein Kennzeichen, zum Beispiel eine Kennzahl. In den hier gezeigten Beispielen ist der 
Prim\"arschl\"ussel fast immer eine Ganzzahl, doch dies muss nicht immer so sein.\\
Die Kernidee hinter den relationalen Datenbanken, ist, dass diese Tabellen verbunden sind. Hier kommen die sogenannten
\textbf{Fremdschl\"ussel (FK)} ins Spiel. Ein Fremdschl\"ussel
besteht aus einer oder mehreren Spalten einer Tabelle, welche den Prim\"arschl\"ussel einer anderen Tabelle 
referenzieren. In unseren "Ubungsbeispielen kommen keine zusammengesetzte Fremdschl"ussel vor.\\
\begin{table}
    \begin{tabular}{|llll|}
    \hline
    {\lstinline!CustomerId!} (PK) & {\lstinline!FirstName!} & {\lstinline!LastName!} & {\lstinline!Email!}               \\ \hline
    1               & Hans      & Muster   & hmuster@example.com \\
    2               & Anja      & Tester   & atester@example.com \\
    3               & Ferdinand & Meier    & fmeier@example.com  \\ \hline
    \end{tabular}

    \caption{Customer}
    \label{tbl:firstExampleStart}
	\begin{tabular}{|lll|}
    \hline
    {\lstinline!ServiceId!} (PK) & {\lstinline!Name!} & {\lstinline!Duration!} \\ \hline
    1              & Waschen, Schneiden        & 30:00    \\
    2              & Waschen, Schneiden, F"onen & 45:00    \\
    3              & T\"onen                     & 90:00    \\ \hline
    \end{tabular} 
    \caption{Service}
    \begin{tabular}{|llll|}
    \hline
    {\lstinline!BookingId!}&{\lstinline!ServiceFk!}  & {\lstinline!CustomerFk!}  & {\lstinline!StartDate!}\\ 
       (PK) &(FK(Service.ServiceId)) & (FK(Customer.CustomerId)) &  \\ \hline
    1 &1                  & 3                   & 21.11.2014 10:30 \\
    2 &1                  & 1                   & 24.11.2014 08:30 \\
    3 & 3                  & 3                   & 23.11.2014 15:00 \\ \hline
    \end{tabular}
    \caption {Booking}
    \label{tbl:firstExampleEnd}
\end{table}

Tabellen~\ref{tbl:firstExampleStart} bis~\ref{tbl:firstExampleEnd} zeigen ein Beispiel f\"ur eine einfache Datenbank, wie 
sie in einem Buchungssystem eines Friseursalons vorstellbar ist. In der Tabelle \lstinline{Customer} sind die Kundeninformation 
aufgelistet. \"Andert sich beispielsweise die Emailadresse eines Kunden, muss diese lediglich an einer Stelle, n\"amlich 
in der entsprechenden Spalte der Customer-Tabelle angepasst werden. Wir sehen hier, dass der Prim\"arschl\"ussel, 
das Feld CustomerId, keine eigentlichen Information zum Benutzer enth\"alt. Doch wieso wurde dieses Feld 
eingef\"uhrt? Betrachten wir die Alternativen f\"ur den Prim\"arschl\"ussel: Wenn die Spalte Email Prim\"arschl\"ussel
w\"are, entst\"anden zwei Nachteile. Einerseits k\"onnten die Kunden ihre Mailadresse nicht mehr wechseln, da sonst
das eindeutige Merkmal der Kundenzeile verloren gehen w\"urde. Andererseits k\"onnen keine zwei Benutzer die gleiche
Mailadresse teilen. Die Spalten \lstinline{FirstName} und \lstinline{LastName} sind nicht eindeutig, und k"onnen somit nicht als 
Prim\"arschl\"ussel (auch zusammengenommen nicht) gew\"ahlt werden. Es g\"abe noch die M"oglichkeit, die 
Kombination \lstinline{FirstName}, \lstinline{LastName} und \lstinline{Email} als Prim\"arschl\"ussel zu w\"ahlen, doch wieder g"abe es das Problem,
dass man die Daten nicht mehr "andern darf. Daher verzichtet man auf komplexe Prim\"arschl\"ussel und f\"uhrt lieber eine 
weitere Zeile ein.

Bei der Tabelle \lstinline{Service} verh\"alt es sich gleich wie bei der \lstinline{Customer}-Tabelle: Da alle anderen Spalten sich \"andern 
k\"onnen, und eventuell nicht eindeutig sind, wurde eine zus\"atzliche Spalte f\"ur den Prim\"arschl\"ussel eingef\"uhrt,

Die \lstinline{Booking}-Tabelle hat zwei Fremdschl\"ussel: Die Spalte \lstinline{ServiceFk} referenziert die Spalte \lstinline{ServiceId} der Tabelle 
Service, und die Spalte \lstinline{CustomerFk} referenziert die Spalte \lstinline{CustomerId} der Tabelle \lstinline{Customer}. Der erste Eintrag
in der \lstinline{Booking}-Tabelle bedeutet also, dass Ferdinand Meier (der Kunde mit der CustomerId 3) am 21. November 2014
um 10:30 einen 45-minutigen Termin zum Haare waschen und schneiden hat (der Service mit der ServiceId 1).

In diesem 
Beispiel enden Spalten, welche andere Tabellen referenzieren auf -Fk, und Prim\"arschl\"ussel auf -Id. Es handelt 
sich hierbei um eine \textbf{Namenskonvention}, an welche in allen Beispielen dieser Unterlagen verwendet wird.
 
 \begin{exercise}\label{ex:changeFK}
Was bedeutet es, wenn beim Eintrag mit der \lstinline{BookingId 2} der \lstinline{ServiceFK} von 1 auf 2 ge\"andert wird?
\end{exercise}
 \begin{exercise}\label{ex:noComposedKey}
Wieso sollten die Spalten \lstinline{ServiceId} und \lstinline{CustomerId} keinen zusammengesetzten Prim\"arschl\"ussel f\"ur die 
Tabelle \lstinline{Booking} bilden?
\end{exercise}
\begin{table}
    \begin{tabular}{|llll|}
    \hline
    {\lstinline!AlbumId!} (PK) & {\lstinline!ArtistName!} & {\lstinline!AlbumName!}  &   {\lstinline!GenreFk!}  (FK)        \\ \hline
    1               & Red Hot Chilli Peppers      & Californication & 1 \\
    2               & The Ramones      & Rocket To Russia  & 2\\
    3               & The Beastie Boys & Ill Communication & 3\\ \hline
    \end{tabular}

    \caption{Album}
    \label{tbl:secondExampleStart}
	\begin{tabular}{|llll|}
    \hline
    {\lstinline!AlbumFk!} (PK, FK) & {\lstinline!TrackId!}   (PK)  & {\lstinline!Name!} & {\lstinline!Duration!} \\ \hline
    3		& 1 & Sure Shot       & 3:20    \\
    1		& 1 & Around the World       & 3:59    \\
    2       	& 2 & Rockaway Beach  &  2:07    \\
    1         	& 4 & Otherside        & 4:15    \\ \hline
    \end{tabular} 
    \caption{Track}
    \label{tbl:tracks}
    \begin{tabular}{|lll|}
    \hline
    {\lstinline!GenreId!}(PK) & {\lstinline!ParentGenreFk!} (FK) & {\lstinline!Name!}\\ \hline
    1 &NULL                  & Rock \\
    2 &1                  & Punk Rock \\
    3 & NULL  & Hip-Hop\\ \hline
    \end{tabular}
    \caption {Genre}
    \label{tbl:secondExampleEnd}
\end{table}

Wir betrachten noch ein Datenbankbeispiel. Tabellen~\ref{tbl:secondExampleStart} 
bis~\ref{tbl:secondExampleEnd}  sind Teil einer Musikbibliotheksdatenbank. In diesem Beispiel kommt in der Tabelle \lstinline{Track}
ein zusammengesetzter Prim"arschl"ussel vor. Da der Track eines Albums durch das Album und der Tracknummer eindeutig 
gegeben ist, und die Tracknummer und das Album sich nie mehr "andert, eignet sich diese Kombination hervorragend
als zumsammengesetzten Prim"arschl"ussel.

Ein weiteres h"aufiges Muster, dass bei relationalen Datenbanken vorkommt, ist bei der \lstinline{Genre}-Tabelle zu finden. Wir sehen,
dass die \lstinline{ParentGenreFk} die eigene Tabelle referenziert. Im Beispiel ist Punk Rock ein Subgenre von Rock. Wir stellen 
ausserdem fest, dass gewisse Genres einen \lstinline{NULL}-eintrag beim Feld ParentGenreFk haben. Dies ist die Notation, welche
besagt, dass dieses Feld f"ur einen Eintrag nicht verwendet wird. Eine Zeile kann nur in als fakultativ deklarierten Spalten \lstinline{NULL}-eintr"age
haben.
 \begin{exercise}\label{ex:NULL}
K"onnte Eintr"age in der Spalte AlbumFk der Tabelle Track leer sein? Wieso bzw. wieso nicht?
\end{exercise}

Die zwei Datenbanken, welche wir in diesem Kapitel betrachteten, werden uns im auch in den n"achsten Kapitel besch"aftigen, und
alle "Ubungen bis auf die Schlusspr"ufung wird sich mit diesen Beispielen befassen. 
Daher empfiehlt es sich, diese Tabellen beim Weiterlesen immer zur Seite zu haben.
\section{Kapiteltest}
In diesem Kapiteltest wird ein etwas Datenmodell eingef"uhrt, welches uns im Rest dieses Kapitels begleiten wird. In dieser Datenbank 
werden Biere, deren Angebot in Bars, und deren Bestellungen von diversen Personen verwaltet. Tabellen~\ref{tbl:testStart} 
bis~\ref{tbl:testEnd} zeigt die Daten dieses Systems. In der Tabelle \lstinline{Bar} sind die Bars aufgelistet. Die \lstinline{Brauerei}-Tabelle listet die Brauereien
im System, und die Kunden erscheinen in der \lstinline{Kunde}-Tabelle. Wenn eine Bar ein Bier im Sortiment hat, existiert ein entsprechenden Eintrag in
der \lstinline{Sortiment}-Tabelle mit dem entsprechenden Verkaufspreis. Da die Preisinformation in dieser Tabelle enthalten ist, k"onnen Biere nicht einfach aus
dem Sortiment gel"oscht werden, da sonst Informationen zu alten Bestellungen verloren gehen w"urden. Anstatt dessen wird der Wert in der 
Deleted-Spalte auf 1 gesetzt.
Eine Bestellung ist ein Eintrag in der Bestellungstabelle. Da jedoch die Bestellung mehrere 
verschiedene Biere beinhalten kann, sind diese in einer separaten Tabelle vermerkt. Jede Bestellung kann mehrere verschiedene Bestellte Biere haben.
Diese Tabelle verf"ugt "uber eine Anzahl bestellter Biere, damit nicht jedes einzelne Bier separat aufgelistet werden muss.

\begin{table}
    \begin{tabular}{|lll|}
    \hline
    {\lstinline!BarId!} (PK) & {\lstinline!Name!} & {\lstinline!Adresse!}               \\ \hline
    1               & Vollmond Taverne & Zentralstrasse 53\\
    2               & Si o No  & Ankerstrasse 6\\
    3               & Brasserie Federal   & Bahnhofplatz 15\\ \hline
    \end{tabular}

    \caption{Bar}
    \label{tbl:testStart}
    
\begin{tabular}{|lll|}
    \hline
    {\lstinline!BrauereiId!} (PK) & {\lstinline!Name!}                      & {\lstinline!Ort!} \\ \hline
    1              & Appenzeller        & Appenzell    \\
    2              & W"adi-Br"au & W"adenswil    \\
    3              &Heineken & Amsterdam    \\
    4              & Turbinenbr"au & Z"urich   \\ \hline
    \end{tabular} 
    \caption{Brauerei}
    \begin{tabular}{|lllll|}
    \hline
    {\lstinline!BierId!} &{\lstinline!BrauereiFk!} &{\lstinline!Name!} & {\lstinline!Deziliter!}  & {\lstinline!Einkaufpreis!}        \\ 
       (PK) &(FK(Brauerei.BrauereiId)) &  & & \\ \hline
    1 &1                  & Qu"ollfrisch                   & 5 & 1.30 \\
    2 &1                  & Vollmond                   & 3.3 & 1.30 \\
    3 & 1                  & Brandl"oscher     & 3.3& 1.20 \\ 
    4 &2                  & Blond Premium & 3.3 & 1.50 \\
    5 &2                  & Dunkel                   & 3.3 & 1.60 \\
    6 & 3                  & Lager                   & 5 & 0.90 \\ 
    7 &4                  & Sprint                   & 3.3 & 1.80 \\
    8 &4                  & Start                   &  3.3 & 1.80 \\
    9 & 4                  & Rekord                   &  3.3 & 1.80 \\ \hline
    \end{tabular}
    \caption {Bier}
        \begin{tabular}{|lll|}
    \hline
    {\lstinline!KundenId!} &{\lstinline!Name!} & {\lstinline!LieblingsbierFk!}        \\ 
       (PK) & & (FK(Bier.BierId))  \\ \hline
    1 &Lisa                  &6 \\
    2 &Urs                  & NULL \\
    3 & Heinz                  & 3 \\ 
    4 & Andrea                 & NULL \\
    \hline
    \end{tabular}
    \caption {Kunde}
    \end{table} 
    \begin{table}
     \begin{tabular}{|lllll|}
    \hline
    {\lstinline!SortimentId!} & {\lstinline!BarFk!} &{\lstinline!BierFk!} & {\lstinline!Preis!}  & {\lstinline!Deleted!}     \\ 
    (PK)& (FK(Bar.BarId) &(FK(Bier.BierId)) & & \\ \hline
    1 &1 &2                  & 4.00 &0\\
    2 &1 &1                  & 6.00 &0\\
    3 & 1 & 3                  & 5.00 &0\\ 
    4 & 1 &7                  & 5.00 &0\\
    5 & 2 &4                  & 5.00 &0\\
    6 & 2 & 7                  & 6.00 &0\\ 
    7 & 2 & 8                  & 6.00 &0\\
    8 & 2 & 9                  & 6.00 &0\\
    9 & 3 & 6                  & 7.00 &0\\
    10 & 3 & 5                  & 5.00 &0\\
    11 & 3 & 4                  & 5.00 &0\\ 
    12 & 3 & 1                  & 7.50 &0\\
    13 & 3 & 2                  & 5.50 &0\\
    14 & 3 & 7                  & 6.00 &0\\
    15 & 3 & 8                  & 6.00 &0\\
    
     \hline
    \end{tabular}
    \caption{Sortiment}
         \begin{tabular}{|llll|}
    \hline
    {\lstinline!BestellungId!} &{\lstinline!KundenFk!} & {\lstinline!BarFk!} & {\lstinline!Zeit!}        \\ 
       (PK) &(FK(Kunde.KundenId)) & (FK(Bar.BarId)) &\\ \hline
    1 &2                  & 1 & 31.12.2014 22:00\\
    2 &1                  & 1 & 31.12.2014 23:23\\
    3 & 1                  & 1 & 31.12.2014 23:24\\ 
    4 &3                  & 2 & 31.12.2014 23:52\\
    5 &4                  & 3 & 1.1.2015 01:21\\
 
    
     \hline
    \end{tabular}
    \caption {Bestellung}
         \begin{tabular}{|lll|}
    \hline
    {\lstinline!BestellungFk!} &{\lstinline!SortimentFk!} & {\lstinline!Anzahl!}        \\ 
       (PK, FK(Bestellung.& (PK, FK(Sortiment. & \\ 
              BestellungId)) &SortimentId)) & \\ \hline
    1&3&2\\
    2&2&1\\
    2&3&2\\ 
    3&4&1\\
    4 &6&3\\
    4&5&1\\ 
    5&12&3\\
   5&9&1\\ 
    
     \hline
    \end{tabular}
    \caption{BestellteBier}
    \label{tbl:testEnd}
\end{table} 
\begin{exercise}
Wir versuchen am Anfang, die Daten zu verstehen. Beschreibe in chronologischer Reihenfolge, welcher Kunde wann wo was bestellt hat.
\end{exercise}
\begin{exercise}
Zu wie viel mal dem Einkaufspreis wird das Vollmond-Bier in der Vollmond-Taverne ausgeschenkt?
\end{exercise}
\begin{exercise}
Wie "andert sich die Datenbank, wenn Urs am 1. Januar 2015 um 2 Uhr im Federal noch zwei Sprint bestellt?
\end{exercise}
\begin{exercise}
Die Tabelle \lstinline{Sortiment} hat einen einfachen Prim"arschl"ussel. Was w"urde passieren, wenn wir hier anstatt dessen
einen zusammengesetzten Schl"ussel aus \lstinline{BarFk} und \lstinline{BierFk} nehmen w"urden.
\end{exercise}
\begin{exercise}
K"onnte man in der Tabelle \lstinline{BestellteBier} f"ur den Prim"arschl"ussel eine Id-Spalte einf"uhren? 
\end{exercise}

\chapter{Relationale Datenbanken in SQL}
In diesem Kapitel lernen wir endlich SQL etwas n"aher kennen. Ziel des Kapitels ist es, dass wir die Beispieltabellen in SQL erstellen
k"onnen. Daf"ur untersuchen wir zuerst, was SQL genau ist, dann lernen wir die wichtigsten Datentypen von SQL kennen.
Anschliessend sind wir bereit, das Datenmodell in SQL zu erstellen, in welches wir dan schliesslich die Daten einf"ugen. Ziel dieses
Kapitels ist, dass wir die Daten f"ur die weiteren Kapitel selbst aufsetzen k"onnen.
\section{Was ist SQL?}
Dr. E. F. Codd, der wie im letzten Kapitel beschrieben die relationale Datenbanken erfunden hat, hat auch eine Sprache 
namens DSL/Alpha entwickelt, um Daten in relationellen Tabellen zu bearbeiten. Nach einigen Weiterentwicklungen durch 
Donald D. Chamberlin und Raymond F. Boyce bei IBM Research entstand dann die Sprache SEQUEL (kurz f"ur Standard 
English Query Language), welche dann aus markenrechtlichen Gr"unden in SQL umbenannt werden musste. SQL ist seit 
1986 von ANSI (American National Standard Institute) standardisiert, und dieser Standard wurde regelm"assig aktualisiert, 
so dass heutzutage auch zum Beispiel die Integration und Abfrage von XML in SQL-Datenbanken standardisiert ist.

Im Gegensatz zu C, C\#, Javascript oder Java ist SQL keine Allzwecksprache. Sie dient lediglich der Bearbeitung und Abfrage
von Relationen Daten. Mit SQL werden lediglich notwendige Ein- und Ausgaben beschrieben. Wie die Daten gespeichert, bzw.
wiedergegeben werden, ist Aufgabe der Datenbankengine. Diese optimiert die Ausf"uhrung der Datenbankabfrage, so dass 
die Daten m"oglichst effizient abgefragt werden.

Eine Software, welche sich umf"anglich mit der Bewirtschaftung von relationalen Datenbanken befasst, nennt sich RDBMS, kurz
f"ur Relational Database Management System. Alle g"angigen RDBMS verwenden SQL oder eine Erweiterung von SQL. Die 
g"angigsten RDBMS-Systeme sind:

\begin{itemize}
\item MySQL, ein Open-Source-System, welches eher wenig Erweiterungen zu SQL verwendet
\item SQL Server von Microsoft. Die SQL-Erweiterung, welche hier verwendet wird, nennt sich T-SQL.
\item Oracle von der gleichnamigen Firma. Die Erweiterte Sprache, welche in Oracle verwendet wird, heisst PL/SQL.
\item SQLite, ein sehr schlankes Open-Source-DBMS. SQLite ist so leicht, dass einige Webbrowser (Safari, Chrome und Opera)
"uber ein eingebautes SQLite verf"ugen.
\item PostgreSQL
\end{itemize}

SQL an sich ist keine vollst"andige Programmiersprache. Viele erweiterte Versionen von SQL, wie PL/SQL,
MySQL oder T-SQL sind jedoch zumindest theoretisch vollst"andige Programmiersprachen. (F"ur die Informatikexperten:
SQL alleine ist nicht Turing-komplett, MySQL, T-SQL, etc. hingegen schon.) Es ist jedoch nicht praktikabel, Datenbankunabh"angige
Anwendungen mit diesen Erweiterungen zu entwickeln. Viele Datenbankanwendungen werden aber nicht direkt mit SQL 
entwickelt, sondern mit einem Toolkit oder einer API aus einer 
Allzwecksprache heraus. Beispiele daf"ur sind JDBC f"ur Java oder das Entity Framework f"ur C\# und Visual Basic.

Man kann SQL ohne irgendetwas zu installieren auf dem Web ausprobieren. Auf 
\url{http://www.w3schools.com/sql/trysql.asp?filename=trysql_select_all} kann man die Webbrowser-interne Datenbankengine
ansteuern. Um die Daten bearbeiten zu k"onnen, muss die Seite jedoch mit Chrome, Opera oder Safari aufgerufen werden,
da die anderen Browser Web-SQL nicht unterst"utzen. Ansonsten kann man auf \url{http://sqlfiddle.com/} mit vielen
verschiedenen Datenbankengines herumexperimentieren.
\section{Datentypen}
In SQL gibt es, "ahnlich wie in Programmiersprachen, verschiedene Datentypen. Es gibt eine Vielzahl von komplexeren Datentypen,
welche f"ur spezifische Zwecke, wie zum Beispiel f"ur Bilder und XML-Dateien existieren. Doch da wir uns vor allem f"ur die
Datenabfrage interessieren, richten wir unseren Fokus auf drei verschiedene Arten von Datentypen: Zahlwerte, temporale Daten und
Zeichenketten.  

\subsection{Zahlwerte}
Ein \textbf{\lstinline{BIT}} kann nur entweder 0 (false) oder 1 (true) sein. Dieser Datentyp ist ideal f"ur Antworten auf Ja/Nein-Fragen, welche nicht
nur in der Informatik h"aufig auftreten.
Ein \textbf{\lstinline{INT}} ist eine Ganzzahl. Es gibt verschiedene Variationen davon f"ur verschiedene gr"ossen (\lstinline{SMALLINT}, \lstinline{BIGINT}, etc.),
doch das Grundprinzip ist das Gleiche. In den vorhergehenden Beispielen wurden INTs vor allem f"ur Schl"ussel verwendet.
Ein \textbf{\lstinline{FLOAT}} ist eine Gleitkommazahl. Dies heisst, dass diese Zahl fast beliebig gross oder klein sein kann, und Stellen nach dem Komma
aufweisen darf.
Ein \textbf{\lstinline{DECIMAL(p,s)}} ist eine Zahl mit $p$ Ziffern insgesamt, davon $s$ nach dem Komma. Dies heisst, dass z.B. $41.46$ als 
\lstinline{DECIMAL(4,2)} gespeichert werden kann, jedoch wird $31.8734$ auf $31.87$ gerundet, und Werte "uber $99.99$ k"onnten gar
nicht erst gespeichert werden. \lstinline{DECIMAL} wird h"aufig f"ur finanzielle Daten (Kosten, Preise, etc.) verwendet. 
\subsection{Temporale Daten}
\textbf{\lstinline{DATE}} ist der Datentyp f"ur ein Datum ohne Zeitangaben.\\
\textbf{\lstinline{TIME}} ist der Datentyp f"ur eine Zeit ohne Datumsangaben.\\
\textbf{\lstinline{DATETIME}} ist der Datentyp f"ur eine Kombination der beiden obigen.

Leider gibt es f"ur eine Zeitdauer keinen einheitlichen Datentyp. Eine m"oglichkeit ist es, da"ur \lstinline{TIME} zu nehmen. Doch daf"ur muss die
Zeitdauer kleiner als 24 Stunden sein. Anstatt dessen kann man sonst einen Zahlwert nehmen, und die Zahleneinheit am Besten gleich im
Spaltennamen der Tabelle erw"ahnen, damit er nicht vergessen wird. Bei der Tabelle~\ref{tbl:tracks} zum Beispiel kann man die Spalte 
\lstinline{Duration} in \lstinline{DurationSeconds} umbenennen, und die Werte dann z.B. als \lstinline{INT}-Werte speichern (falls einem die Sekundenbruchteile
nicht interessieren).
\subsection{Zeichenketten}
F"ur Zeichenketten gibt es zwei verschiedene Formate:
\textbf{\lstinline{CHAR(l)}} ist eine Zeichenkette mit fixer L"ange \lstinline{l}.\\
\textbf{\lstinline{VARCHAR(l)}} ist eine Zeichenkette mit H"ochstl"ange \lstinline{l}.\\

\begin{exercise}
Wieso w"ahlt man bei Zeichenketten nicht immer ein \lstinline{VARCHAR} mit sehr grosser H"ochstl"ange? Dies w"urde doch in jedem Fall funktionieren. 
\end{exercise}

\begin{exercise}
Bestimme die Datentypen des Buchungsdatenbank aus dem vorhergehenden Kapitel.
\end{exercise}
\begin{exercise}
Bestimme die Datentypen des Musikdatenbank aus dem vorhergehenden Kapitel.
\end{exercise}
\section{Datenbanken erstellen in SQL}
Mit dem Wissen, das wir uns in den letzten Kapitel angeeignet haben, ist es relativ einfach, eine Datenbank mit SQL zu erstellen. 
\begin{example}
Erstelle die Tabelle \lstinline{Booking} von~\ref{tbl:firstExampleEnd}.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle \lstinline{Booking}}]  
CREATE TABLE Booking (
  BookingId INT NOT NULL,
  ServiceFk INT NOT NULL,
  CustomerFk INT,
  StartDate DATETIME NOT NULL,
  CONSTRAINT pk_booking PRIMARY KEY (BookingId),
  CONSTRAINT fk_booking_service FOREIGN KEY (ServiceFk) 
    REFERENCES Service(ServiceId),
  CONSTRAINT fk_booking_customer FOREIGN KEY 
    (CustomerFk) 
    REFERENCES Customer(CustomerKey)
	
);
\end{lstlisting}
\end{example}
Da dies der erste SQL-Code in diesen Unterlagen ist, zuerst einige Bemerkungen: Wie in vielen Programmiersprachen d"urfen bei Leerschl"agen
beliebig viele weitere Leerschl"age oder Zeilenumbr"uche geschrieben werden. Man k"onnte auch diesen Code auf eine Zeile packen, oder jedes 
Wort dieses codes auf eine separate Zeile legen. In diesem Buch ist der Code mit etwas mehr Zeilenumbr"uchen versehen als sonst in der Praxis
"ublich, damit die Lesbarkeit auf Papier einfacher wird. In den Beispielen werden Zeilen, welche sich auf die Vorzeile beziehen einger"uckt, um eine
"Ubersicht "uber den Code zu schaffen. Dies ist eine g"angige Praxis in allen Programmiersprachen.

Wir sehen in diesem Codebeispiel, dass gewisse Worte in Grossbuchstaben geschrieben sind. Das sind die SQL-Schl"usselw"orter. SQL 
unterscheidet eigentlich gar nicht zwischen Klein-und Grossbuchstaben. SQL ist also \textbf{case-insensitive} (Es gibt jedoch Ausnahmen, wie
zum Beispiel der Textvergleich von Datens"atzen). Es hat sich jedoch eingeb"urgert SQL-Schl"usselw"orter in Grossbuchstaben zu schreiben. 
Dem wird auch in diesen Unterlagen Folge geleistet.

Die erste Zeile beschreibt, was wir tun wollen, n"amlich eine Tabelle erstellen. Die folgenden Felder sind die Spalten der Tabelle. Zuerst wird
jeweils der Name der Spalte geschrieben, dann der Datentyp. Wenn eine Spalte nicht leer sein darf, dann wird dies mit \lstinline{NOT NULL}
gekennzeichnet. In unserem Beispiel d"urfen auch Buchungen get"atigt werden, bei welchen der Kunde fehlt, da er zum Beispiel nicht 
bekannt ist. Prim"arschl"ussel und Fremdschl"ussel werden mit dem \lstinline{CONSTRAINT}-Keyword erstellt. Solche Constraints erhalten einen Namen,
damit man sie sp"ater auch noch modifizieren oder l"oschen kann. Die Namen \lstinline{pk_booking}, \\
\lstinline{fk_booking_service} und \lstinline{fk_booking_customer} stammen aus
Konventionen, wenn man m"ochte, kann man Constraints beliebig nennen. Auf den Namen folgt die Art des Constraints. In dieser Lektion 
werden nur die Contraints ``Primary Key'' und ``Secondary Key'' behandelt. Nach der Art des Schl"ussels wird deklariert, auf welche Spalten der
Constraint wirkt. Alle Constraints, welche wir hier eignef"ugt haben, gelten nur f"ur eine einzelne Spalte.
Zeilen 7 bis 12 besch"aftigen sich mit den Fremdschl"ussel. Zus"atzlich zur Information, welche Spalte teil des Schl"ussels ist, wird auch noch
beschrieben, welche Spalten welcher Tabelle referenziert werden.

Hier noch ein Beispiel, wie die Tabelle ~\ref{tbl:tracks}  in SQL aussieht:
\begin{example}
Erstelle die Tabelle \lstinline{Track} in SQL 
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle \lstinline{Track}}]  
CREATE TABLE Track (
	AlbumFk INT NOT NULL,
	TrackId INT NOT NULL,
	Name NVARCHAR(200),
	DurationSeconds INT NOT NULL,
	CONSTRAINT pk_track PRIMARY KEY 
		(AlbumFk, TrackId),
	CONSTRAINT fk_track_album FOREIGN KEY (AlbumFk)
		REFERENCES Album(AlbumId)
);
\end{lstlisting}
\end{example}
\begin{exercise}
Erstelle die zwei anderen Tabellen dieser Datenbank in SQL.
\end{exercise}
\begin{exercise}
Erstelle die restlichen zwei Tabellen der Buchungsdatenbank in SQL.
\end{exercise}
\section{Daten einsetzen}
Eine Datenbank abzufragen macht erst Sinn, wenn Daten drin sind. Dies geschieht mit dem \textbf{\lstinline{INSERT INTO}}-Statement. Dieses Statement besteht aus zwei Teilen.
Im ersten Teil wird angegeben, in welche Spalten welcher Tabelle Werte eingesetzt werden. Im zweiten-Teil, nach dem \textbf{\lstinline{VALUES}}-Keyword, werden die 
Werte eigesetzt. Das Ganze sieht zum Beispiel f"ur die \lstinline{Booking}-Tabelle so aus:
\begin{example}
F"uge f"ur Ferdinand Meier noch einen Termin zum Haare waschen und schneiden am 21. November 2014 um halb elf in die Datenbank ein.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einf"ugen eines Datensatzes}]  
INSERT INTO Booking 
	(BookingKey, ServiceFk, CustomerFk, StartDate)
VALUES (4, 1, 3, '2014-11-21 10:30')
\end{lstlisting}
\end{example}
In diesem Beispiel sehen wir auch, wie wir in SQL mit Datentypen umgehen m"ussen: Zahlenwerte schreiben wir ganz gew"ohnlich aus. Alle
anderen Datentypen, also Zeitdaten und Zeichenketten schreiben wir mit Hochkommas. Zeitdaten werden normalerweise im Format 
\lstinline{yyyy-MM-dd HH:mm(:ss)}, also zuerst Jahr, dann Monat, anschliessend Tag geschrieben.

Wir k"onnen auch gleich mehrere Datens"atze in einem Befehl in eine Tabelle einf"ugen. Daf"ur muss man die verschiedenen Datens"atze mit Komma 
voneinander trennen:
\begin{example}

F"uge mittels einer Abfrage folgende Termine in die Termindatenbank ein.
\begin{itemize}
\item Ferdinand Meier, Waschen und Schneiden, am 21. November 2014 um halb elf.
\item Anja Teste, Waschen, Schneiden und F"onen, 26. November 2014 um 14:45.
\end{itemize}
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einf"ugen mehrerer Datens"atze}]  
INSERT INTO Booking 
	(BookingKey, ServiceFk, CustomerFk, StartDate)
VALUES (4, 1, 3, '2014-11-21 10:30'),
       (5, 2, 2, '2014-11-26 14:45')
\end{lstlisting}
\end{example}
In der Praxis ist es h"aufig der Fall, dass Spalten wie \lstinline{BookingKey} automatisch generiert werden. Wie man in der Datenbank spezifiziert, dass ein Feld
automatisch generiert werden soll, variiert von System zu System. Daher gehen wir hier nicht n"aher darauf ein. Wenn eine Spalte freiwillig ist, oder
automatisch generiert wird, dann muss man die Spalte im \lstinline{INSERT}-Statement nicht angeben. Wenn wir also wissen, dass der \lstinline{BookingKey} automatisch
generiert wird, reicht auch schon folgendes zum Einf"ugen der beiden Datens"atze im letzten Beispiel:


\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einf"ugen mit automatisch generiertem Feld}]  
INSERT INTO Booking 
	(ServiceFk, CustomerFk, StartDate)
VALUES (1, 3, '2014-11-21 10:30'),
       (2, 2, '2014-11-26 14:45')
\end{lstlisting}

Wenn man Daten in SQL-Tabellen einf"ugt, m"ussen die Referenzen existieren. Wenn wir versuchen w"urden, eine Buchung mit \lstinline{CustomerFk} 4 einzuf"ugen,
w"urden wir einen Fehler zur"uckerhalten, selbst wenn wir in der n"achten Zeile den Kunden mit der \lstinline{CustomerId} 4 erstellen w"urden. Die 
Erstellungsreihenfolge ist also wichtig.  
\begin{exercise}
Erstelle sie die Beispielsdatens"atze der \lstinline{Tracks}-Datenbank mittels SQL-Skript. 
\end{exercise}
\section{Zusammenfassung}
\begin{itemize}
\item Wir kennen die wichtigsten Datentypen von SQL und wissen, wann welcher Datentyp eingesetzt wird.
\item Wir wissen, wie wir anhand eines existierendes Tabellenmodells die dazugeh"orige SQL-Datenbank erstellen.
\item Wir k"onnen Eintr"age in die SQL-Datenbank generieren.  
\end{itemize}
\section{Kapiteltest}
Wir arbeiten wieder mit der Datenbank aus Tabellen~\ref{tbl:testStart} bis~\ref{tbl:testEnd}.
\begin{exercise}
Erstelle die Datenbanktabellen \lstinline{Bestellung} und \lstinline{BestellteBier} mittels SQL.
\end{exercise}
\begin{exercise}
Urs hat am 1. Januar 2015 um 2 Uhr im Federal noch zwei Sprint bestellt. Bilde dies mittels Skript in die Datenbank ab.
\end{exercise}
\chapter{Datenbankabfragen \"uber eine Tabelle}
Jetzt dass wir wissen, wie wir unsere Datenbanken erstellen und Daten einf"ugen, k"onnen wir anfangen, Daten abzufragen. In diesem Kapitel lernen wir, Abfragen
auf eine einzelne Tabelle abzusetzen. Das Ziel dieses Kapitels ist es, dass der Leser die Daten aus einer einzelnen Tabelle in einem sinnvollen Format darstellen kann.
Dies lernen wir in drei Schritten: Zuerst fragen wir s"amtliche Datens"atze einer Tabelle in fixer Reihenfolge ab und konzentrieren uns darauf, wie wir die Zeilendaten
darstellen k"onnen. Danach schauen wir, wie wir die Daten ordnen k"onnen, und schliesslich betrachten wir, wie wir gewisse Zeilen der Tabelle herausfiltern. Mit 
diesen drei Techniken zusammen hat man die Kontrolle "uber die Abfrage "uber eine Tabelle. Dieses Wissen ist auch f"ur Abfragen "uber mehrere Tabellen essenziell. 

Um mit den Abfragen herumzuexperimentieren, stehen die Datenbankbeispiele dem Leser auf sqlfiddle zur Verf"ugung. Das Buchungsbeispiel befindet sich auf 
\url{http://sqlfiddle.com/#!5/4f43d}, und die Musikdatenbank befindet sich auf \url{http://sqlfiddle.com/#!6/846d6}. Auf die Kapiteltestdatenbank kann man 
"uber \url{http://sqlfiddle.com/#!9/e0cb4} zugreifen.
\section{Aufbau einer \lstinline{SELECT}-Abfragen}
 Um Daten abzufragen, 
verwendet man das \lstinline{SELECT}-Keyword. Die einfachste Datenabfrage sieht wie folgt aus:
\begin{example}
Erstelle eine Abfrage, welche die \lstinline{Track}-Tabelle zur"uckgibt.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einfache SQL-Abfrage}]  
SELECT *
FROM Track
\end{lstlisting}
\end{example}
Diese SQL-Abfragen kann man problemlos auf \url{http://sqlfiddle.com/#!6/846d6} ausprobieren. Dazu gibt man die Abfrage im rechten Texteditorfenster ein und dr"uckt
 dann auf ``Run SQL''. Danach sieht man das Resultat unten an den Textfenster.
Eine SQL-Abfrage in der Datenbank gibt immer eine Tabelle zur"uck. Diese Datenbankabfrage gibt uns die ganze Tabelle Track zur"uck. Nach dem \lstinline{SELECT}-Keyword muss man eingeben, welche Daten man 
im Resultat erhalten m"ochte. * steht f"ur s"amtliche Spalten. Nach dem \lstinline{FROM} steht, von welcher Tabelle man die Felder nehmen will. Im folgenden Beispiel wird sichtbar, wie
wir nur bestimmte Spalten der Tabelle ausw"ahlen k"onnen:
\begin{example}
Gebe die Spalten \lstinline{Name} und \lstinline{DurationSeconds} mittels Abfrage zur"uck.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Spezifische Spalten abfragen}]  
SELECT Name, DurationSeconds
FROM Track
\end{lstlisting}
\end{example}
Da ein wichtiger Zweck von SQL ist, Daten "uber mehrere Tabellen abzufragen, ist es oft praktisch, Tabellen in den Abfragen einen neuen Namen zu geben. 
Dann kann es auch n"otig sein, Spalten zusammenzufassen, denn wenn mehrere Tabellen zusammengefasst werden, kann es vorkommen, 
dass gewisse Spalten gleich heissen. Dieses Beispiel macht das gleiche wie das letzte, die Tabelle Track wird jedoch t genannt, und die Track-Spalte
wird zu Trackname umbenannt. 
\begin{example}
Erstelle eine Abfrage, welche den Namen und die Zeitdauer der Lieder zur"uckgibt, Die Spalte mit dem Namen sollte \lstinline{Trackname} heissen, und in der Abfrage
sollte die Tabelle \lstinline{Track t} genannt werden. 
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Tabelle und Spalten benennen}]  
SELECT t.Name as Trackname, t.DurationSeconds
FROM Track t
\end{lstlisting} 
\end{example}
Bei \lstinline{SELECT}-Abfragen k"onnen nicht nur Spalten aus der Tabelle, sondern auch Konstanten oder berechnete Werte abgefragt werden. In folgendem
Beispiel verwenden wir Konstante Werte sowie Funktionen, um Spalten zu berechnen.
\begin{example}
\label{ex:customTable}
Erstelle eine Abfrage, welche die Tabelle \lstinline{Track} abfragt. Die erste Spalte soll den Namen \lstinline{Status} tragen und dessen Wert sollte f"ur jede Zeile \lstinline{'In Library'} sein. 
Die zweite Spalte soll \lstinline{Trackname} heissen und den Namen in Kleinbuchstaben sein. Die dritte Spalte sollte Die (abgerundete) Anzahl Minuten des Tracks 
anzeigen und \lstinline{DurationMinutes} heissen. 

\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Berechnete Spalten}]  
SELECT 'In Library' AS Status, 
	LOWER(t.Name) as Trackname, 
	t.DurationSeconds/60 AS DurationMinutes
FROM Track t
\end{lstlisting}
Wir sehen in der ersten Zeile, dass wir mit Selektieren eines konstanten Werts, hier \lstinline{'In Library'}, bewirken kann, dass jede Zeile der Resultattabelle den
Wert aufweist. Mit der String-Funktion \lstinline{LOWER()} k"onnen wir eine Zeichenkette in Kleinbuchstaben augeben. Und mit einer Ganzzahldivision, wie wir es schon von
anderen Programmiersprachen her kennen, errechnen wir die Zeitdauer in Minuten.  
\end{example}

Weiter gibt es noch das Schl"usselwort \lstinline{DISTINCT} zu erw"ahnen. mit diesem Schl"usselwort werden doppelte Eintr"age eliminiert.
\begin{example}
Wieviel Minuten (abgerundet) k"onnen die Lieder der \lstinline{Track}-Tabelle dauern?
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={DISTINCT}]  
SELECT DISTINCT t.DurationSeconds/60 
  AS DurationMinutes
FROM Track t
\end{lstlisting}
\end{example}
\begin{exercise}
\label{ex:inverse}
Finde eine Datenabfrage "uber die bestehenden Tabellen, welche die Werte aus Tabelle~\ref{tbl:exbySolution} zur"uckgibt
\begin{table}
    \begin{tabular}{|ll|}
    \hline
    NameLower & DurationsMilliseconds       \\ \hline
    waschen, schneiden & 1800000 \\
    waschen, schneiden, f"onen & 2700000 \\
    t"onen & 5400000\\ \hline
    \end{tabular}

    \caption{Erw"unschtes Resultat aus Aufgabe~\ref{ex:inverse}}
    \label{tbl:exbySolution}
\end{table}

\end{exercise}

\section{Sortieren mit \lstinline{ORDER BY}}
Grunds"atzlich ist das Resultat einer SQL-Abfrage ungeordnet. Zwar werden in Praxis die Resultate in den meisten Datenbank-Engines nach 
Prim"arschl"ussel geordnet, doch davon kann man nicht immer ausgehen. Daher existiert die \lstinline{ORDER BY}-Klausel, mit welcher man bestimmen kann, 
nach welchen Spalten das Resultat geordnet wird. Diese Spalten m"ussen dabei gar nicht unbedingt im Resultat vorkommen. Die Datenbankengine
sortiert zuerst nach der ersten Spalte, dann nach der zweiten, etc. Wenn nicht anders angegeben, wird aufsteigend sortiert. Mit dem
\lstinline{DESC}-Schl"usselwort nach dem Spaltennamen kann man absteigend sortieren. Das folgende Beispiel liefert das Resultat aus Tabelle~\ref{tbl:orderby}.
\begin{example}
Ordnen sie die Tabelle Track absteigend nach Albumsfremdschl"ussel und dann aufsteigend nach Namen.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Order By}] 
SELECT *
FROM Track t
ORDER BY AlbumFk DESC, Name
\end{lstlisting} 
\end{example}
\begin{table}[H]
	\begin{tabular}{|llll|}    \hline
    AlbumFk (PK, FK) & TrackId   (PK)  & Name & Duration \\ \hline
    3		& 1 & Sure Shot       & 3:20    \\
    2       	& 2 & Rockaway Beach  &  2:07    \\
    1		& 1 & Around the World       & 3:59    \\
    1         	& 4 & Otherside        & 4:15    \\ \hline
    \end{tabular} 
    \caption{Tracks nach Album und Namen sortiert}
    \label{tbl:orderby}
\end{table}
\begin{exercise}
Sortiere die Buchungen von Buchungen absteigend nach Termin.
\end{exercise}
\begin{exercise}
Sortiere die Alben nach Genre, und dann absteigend nach K"unstlername.
\end{exercise}

\section{\lstinline{WHERE}-Bedingungen}
Wie wir bereits erw"ahnt haben, k"onnen Tabellen in SQL riesig werden. Um den "Uberblick zu behalten, m"ochte man meistens nur einen Teil der
Resultate zur"uckbekommen. Um dies zu erreichen, kann man die Daten filtern. Der einfachste Weg, die Daten zu beschr"anken, ist es, nur die obersten
n Datens"atze zu holen. Leider ist diese Klausel nicht standardisiert, und der Syntax ist in allen g"angigen Systemen anders (\lstinline{TOP} ins T-SQL, \lstinline{LIMIT} 
in MySQL und noch mal anders in Oracle). Daher verzichten wir hier auf eine Einf"uhrung dieser Klausel.

Um gezielt nach Bedingungen zu filtern, braucht man in allen Versionen von SQL die \lstinline{WHERE}-Klausel. 

\begin{example}
Suche alle Lieder, welche l"anger als 4 Minuten dauern.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einfacher \lstinline{WHERE}-Filter}] 
SELECT *
FROM Track t
WHERE DurationSeconds > 4*60
\end{lstlisting} 
\end{example}
Wenn man mehrere Bedingungen zusammen verbinden m"ochte, tut man dies entweder mit \lstinline{OR} oder mit \lstinline{AND}. Mit diesen zwei 
Verbindungsm"oglichkeiten, dem \lstinline{NOT}-Ausdruck und entsprechender Klammerung kann man beliebig komplexe logische Verbindungen zwischen
Bedingungen bauen. Da Auslagenlogik jedoch nicht Teil dieses Kurses ist, betrachten wir ein ganz einfaches Beispiel.

\begin{example}
Suche nach allen Tracks, welche nicht am Anfang des Albums sind und l"anger als 4 Minuten dauern.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Mehrere Bedingungen mit \lstinline{AND}}] 
SELECT *
FROM Track t
WHERE DurationSeconds > 4*60 AND TrackId <> 1
\end{lstlisting} 
\end{example}
\begin{exercise}
Frage alle Termine in der Woche vom 24. bis 30. November 2014 ab. Bemerkung: Daten kann man gleich wie Zahlen mit den Symbolen
kleiner als ($<$) und gr"osser als ($>$) vergleichen. 
\end{exercise}
\subsection{Textvergleich}
Bei Textfelder gibt es die M"oglichkeit, nach Teilstrings zu filtern. Mit dem Schl"usselwort \lstinline{LIKE} kann man nach Anfang, Ende oder innerer Teil filtern. 
Das \lstinline{%}-Zeichen dient dabei als Wildcard. Kommt es nur nach dem Suchtext vor (\lstinline{'Text\%'}), so wird der Text nach dem Anfang gefiltert, kommt es nur vor dem 
Suchtext vor, so wird nach dem Ende gefiltert (\lstinline{'%Text'}). Wenn das \lstinline{%}-Zeichen auf beiden Seiten des Suchtexts steht, so darf der Suchtext an einer beliebigen 
Stelle vorkommen.
\begin{example}
Suche nach Lieder, deren Name mit ``Sure'' anfangen 
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Textvergleich mit \lstinline{LIKE}}] 
SELECT *
FROM Track t
WHERE Name LIKE 'Sure%'
\end{lstlisting} 
\end{example}
\subsection{Vergleich mit \lstinline{NULL}}
Wenn ein Feld leer sein darf, muss man mit dem Filtern aufpassen: Felder, welche \lstinline{NULL} sind, k"onnen nicht verglichen werden, und werden deshalb
nicht retourniert. Daher ist die L"osung des folgenden Beispiels nicht ganz trivial:

\begin{example}
Finde alle Genre, deren Elterngenre nicht den Schl"ussel 1 haben.
\end{example}
Intuitiv w"urde man diese Aufgabe vielleicht wie folgt l"osen, doch das Resultat der folgenden Abfrage ist leer:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Vergleich gibt keine \lstinline{NULL}-Werte zur"uck}] 
SELECT *
FROM Genre
WHERE ParentGenreFk <> 1
\end{lstlisting}
Wir wollten eigentlich nach allen Genres suchen, welche nicht Subgenres von Rock sind. Doch leider wird das \lstinline{NULL} nicht verglichen, bzw. scheitert
der Vergleich. Man ist geneigt, das Problem folgendermassen zu beheben, doch dies n"utzt nichts:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Wirkungsloser \lstinline{NULL}-Vergleich}] 
SELECT *
FROM Genre
WHERE ParentGenreFk <> 1 OR ParentGenreFk = NULL
\end{lstlisting}
Das Problem ist nach wie vor, dass der Vergleich mit \lstinline{NULL} nicht funktioniert. Wenn man mit einem \lstinline{NULL}-Wert vergleicht, muss man immer \lstinline{IS NULL}
verwenden, wie folgt:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Funktionierender \lstinline{NULL}-Vergleich}] 
SELECT *
FROM Genre
WHERE ParentGenreFk <> 1 OR ParentGenreFk IS NULL
\end{lstlisting}
\section{Zusammenfassung}
\begin{itemize}
\item Wir kennen die Grundstruktur einer \lstinline{SELECT}-Abfrage, und wissen, wie wir z.B. auf Sqlfiddle eine Abfrage absetzen k"onnen. 
\item Wir k"onnen eine Tabelle nach bestimmten Tabellenspalten abfragen.
\item Wir k"onnen sowohl die Spalten wie auch die Tabelle einer Abfrage benennen.
\item Wir wissen, wie wir kleinere Berechnungen direkt in der \lstinline{SELECT}-Abfrage durchf"uhren k"onnen.
\item Wir wissen, wie wir Mehrfachresultate in einer Abfrage vermeiden k"onnen.
\item Wir wissen, wie wir die Abfrageresultate ordnen k"onnen.
\item Wir wissen, wie wir Abfrageresultate filtern k"onnen.
\item Wir sind uns der Probleme, welche auftreten k"onnen, wenn nach \lstinline{NULL} gefiltert wird, bewusst, und wissen, wie wir diese Probleme vermeiden k"onnen.
\end{itemize}
\section{Kapiteltest}
\begin{exercise}
Erstelle eine Abfrage, welche die vollst"andige Tabelle Bar zur"uckgibt
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche die Biernamen in Kleinbuchstaben, die Anzahl Milliliter der Flaschen, und den Einkaufspreis in Euro (bei einem Wechselkurs von 1.2)
zur"uckgibt.
\end{exercise}
\begin{exercise}
Welche Flaschengr"ossen gibt es in dieser Datenbank? Erstelle dazu eine Abfrage. 
\end{exercise}
\begin{exercise}
Zeige, zu welchen Preisen das Bier mit der Id 7 verkauft wird.
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche die Tabelle Sortiment nach Bier geordnet zur"uckgibt.
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche alle Biere, die im Namen ein Umlaut ("a, "o oder "u) enthalten, anzeigt.
\end{exercise}
\begin{exercise}
Zeige alle Biere der Brauerei mit der Id 1 mittels Datenbankabfrage an.
\end{exercise}
\begin{exercise}
Zeige alle Biere an, deren Einkaufspreis pro Deziliter unter 40 Rappen ist.
\end{exercise}



\chapter{Abfragen "uber mehrere Tabellen}
Jetzt, da wir wissen, wie wir die Daten aus einer Tabelle sinnvoll abfragen, k"onnen wir sehen, wie wir Daten aus mehreren Tabellen zusammenf"ugen 
k"onnen. Dadurch k"onnen wir endlich die Macht der relationalen Datenbanken nutzen, denn so haben wir die M"oglichkeit, zusammenh"angende Informationen
zusammen darzustellen. Eine M"oglichkeit besteht darin, das Resultat einer Abfrage gleich f"ur eine weitere Abfrage zu verwenden. Eine derartige verschachtelte Abfrage 
nennt sich \textbf{Unterabfrage}. Eine der h"aufigsten Anwendungen von Unterabfragen ist bei einer Abfrage "uber eine Menge von Werten. Daher betrachten wir zuerst 
solche sogenannten \textbf{Mengenabfragen}, bevor wir dann mit Hilfe dieser die Unterabfragen einf"uhren. Es gibt auch andere Arten von Unterabfragen, doch auf diese
werden wir hier nicht eingehen.
Die zweite M"oglichkeit, Tabellen miteinander verbindet, ist, indem man Tabellen bei den Schl"ussel miteinander verbindet.
Man kann es sich wie folgt vorstellen: Eine Zeile einer Tabelle, welche einen Fremdschl"ussel hat, wird mitsamt den Daten, welche in der referenzierten Zeile
der referenzierten Tabelle sind, wiedergegeben. Ein derartiges Hineinladen von Datens"atzen nennt man \textbf{\lstinline{JOIN}}.
  
\section{Unterabfragen}

\subsection{Mengenabfragen}
Anhand unserer jetztigen Kenntnisse, w"urden wir nach den Kunden, die entweder Tester, Muster oder Test heissen, wie folgt suchen:
\begin{example}
Finde alle Kunden, welche Tester, Muster oder Test heissen.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Vergleich mit mehreren Werten}] 
SELECT *
FROM Customer
WHERE LastName = 'Muster' OR LastName = 'Tester' 
	OR LastName = 'Test'
\end{lstlisting}
\end{example}
Dies funktioniert bei nur drei Vergleichen relativ gut. Mit mehr als ca. 10 Namen wird diese Notation jedoch m"uhsam. Daher kann man hier das Keyword \lstinline{IN}
verwenden, um die Abfrage k"urzer und lesbarer zu machen:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={ Mengenabfrage }] 
SELECT *
FROM Customer
WHERE LastName IN ('Muster', 'Tester', 'Test')
\end{lstlisting}
\subsection{Unterabfragen}
Eine einfache Art, Tabellen miteinander zu verbinden, sind Unterabfragen. Unterabfragen sind den Mengenabfragen aus dem
vorhergehenden Abschnitt "ahnlich. Lediglich ist die Vergleichsmenge nicht explizit aufgeschrieben, sondern ebenfalls das Resultat einer anderen
Abfrage. 

\begin{example}
Gebe alle Lieder von Bands, welche mit  ``The'' anfangen, zur"uck.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Unterabfrage}] 
SELECT *
FROM Tracks
WHERE AlbumFk IN (
	SELECT AlbumId
	FROM Album
	WHERE ArtistName LIKE 'The%'
)
\end{lstlisting} 
Diese L"osung ist offensichtlich zweistufig: 
In der Unterabfrage werden alle Ids der Alben, deren K"unstler mit ``The'' anfangen abgefragt. 
Danach wird die AlbumFk-Spalte mit diese Ids verglichen.
\end{example}
\begin{exercise}
Erstelle eine Abfrage, welche alle Buchungen zur"uckgibt, deren Service l"anger als 30 Minuten dauert.
\end{exercise}
\section{\lstinline{JOIN}}
\subsection{\lstinline{INNER JOIN}}
Bisher haben alle unsere Datenbankabfragen nur Werte aus einer Tabelle zur"uckgegeben. Doch wirklich m"achtig wird SQL erst, wenn wir
Tabellen zusammenf"ugen. Dies geschieht zum Beispiel mit \lstinline{INNER JOIN}. Die \lstinline{INNER JOIN}-Klausel kommt im \lstinline{FROM}-Teil der Abfrage zum 
Einsatz, und f"ugt jeweils zwei Tabellen zusammen. Zu einem \lstinline{JOIN}-Befehl geh"ort immer auch ein \lstinline{ON}-Befehl, welcher beschreibt, unter welcher
Bedingung zwei Datens"atze zusammengef"ugt werden. 
\begin{example}
Erstellen wir so f"ur den Fris"or eine Ansicht, bei welchem er den Namen des Kunden 
und der Zeitpunkt des Termins sieht:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einfacher INNER JOIN}, label={lst:firstjoin}] 
SELECT c.FirstName, c.LastName, b.StartDate
FROM Customer c INNER JOIN Booking b
	ON b.CustomerFK = c.CustomerId
\end{lstlisting}
\end{example}
\begin{table}
    \begin{tabular}{|lll|}
    	\hline
    	FirstName &LastName & StartDate        \\ 
       	Ferdinand	&Meier 	& 21.11.2014 10:30 \\
   	Hans	 &	Muster & 24.11.2014 08:30 \\
    	Ferdinand& Meier & 23.11.2014 15:00 \\ \hline
    \end{tabular}
    \caption{\lstinline{JOIN} "uber Customer und Booking}
    \label{tab:firstjoin}
\end{table}
Das Resultat dieser Abfrage ist in Tabelle zu sehen. Dabei k"onnen Eintr"age von gewissen Tabellen mehrfach auftreten. In unserem Beispiel
taucht Ferdinand Meier in zwei Eintr"agen auf. Beim \lstinline{INNER JOIN} spielt es, im Gegensatz zu anderen \lstinline{JOINS}, welche wir sp"ater sehen werden,
keine Rolle, welche Tabelle links und welche rechts des \lstinline{JOIN}s steht. So k"onnen wir auch mehrere \lstinline{INNER JOINS} aneinanderreihen, um beliebig
viele Tabellen zusammenf"ugen. 

\begin{example}
Erstelle eine Abfrage, welche Name von Track, K"unstler, Album und Genre zu jedem Eintrag der \lstinline{Tracks}-Tabelle zur"uckgibt.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Mehrere \lstinline{INNER JOIN}s}] 
SELECT t.Name as TrackName, a.ArtistName, 
	a.AlbumName, g.GenreName
FROM Track t 
	INNER JOIN Album a ON t.AlbumFk = a.AlbumId
	INNER JOIN Genre g ON a.GenreFk = g.GenreId 
\end{lstlisting}
\end{example}
\begin{exercise}
Erweitere Listing~\ref{lst:firstjoin} um den Namen des Services und dem Enddatum. Um das Enddatum zu berechnet, kannst du auf die eingebaute
SQL-Funktion \lstinline{DATEADD(minute, x, StartDate)} zur"uckgreifen. So erh"altst Du das Datum, welches \lstinline{x} Minuten nach dem Startdatum ist.
\end{exercise}
\begin{exercise}
\label{ex:selfjoin}
Verbinde die \lstinline{Genre}-Tabelle mit sich selbst, so dass in der ersten Spalte das Untergenre und in der zweiten Spalte das Genre steht.
\end{exercise}
\subsection{\lstinline{OUTER JOIN}}
Wie der aufmerksame Leser vielleicht schon bemerkt hat, sind bei einem \lstinline{JOIN} nicht alle Eintr"age der verkn"upften Tabellen vorhanden. Zum 
Beispiel taucht in der  Tabelle~\ref{tab:firstjoin} Anja Tester nicht mehr auf. Es kann sein, dass man s"amtliche Eintr"age einer Tabelle erhalten 
m"ochte. Daf"ur ist der \lstinline{OUTER JOIN}. Ein \lstinline{LEFT}, bzw. ein \lstinline{RIGHT OUTER JOIN} stellt sicher, dass jeder Eintrag der Tabelle links, bzw. rechts
des Schl"usselworts mindestens einmal auftritt. Ein \lstinline{FULL OUTER JOIN} stellt sicher, dass jeder Eintrag beider Tabellen vorkommt. Wenn man 
bei der Abfrage zu Tabelle~\ref{tab:firstjoin} das \lstinline{INNER JOIN} durch ein \lstinline{LEFT OUTER JOIN} ersetzen w"urde, so erh"alte man 
Tabelle~\ref{tab:outerjoin}.
\begin{table}[H]
    \begin{tabular}{|lll|}
    	\hline
    	FirstName &LastName & StartDate        \\ 
       	Ferdinand	&Meier 	& 21.11.2014 10:30 \\
   	Hans	 &	Muster & 24.11.2014 08:30 \\
    	Ferdinand& Meier & 23.11.2014 15:00 \\
    	Anja & Tester & NULL \\ \hline
    \end{tabular}
    \caption{\lstinline{LEFT OUTER JOIN}}
    \label{tab:outerjoin}
\end{table}
\begin{exercise}
F"uhre von Hand die vier \lstinline{JOIN}s (\lstinline{INNER} / \lstinline{LEFT OUTER}\\ / \lstinline{RIGHT OUTER} / \lstinline{FULL OUTER})-Operationen auf die
Tabelle Genre und sich selbst (wie in Aufgabe~\ref{ex:selfjoin}) aus.
\end{exercise}

\subsection{\lstinline{JOIN} mit Unterabfragen}
Joins sind nicht nur mit bereits existierenden Tabellen m"oglich. Wir k"onnen Joins auch mit berechneten Tabellen ausf"uhren. Hier ein Beispiel:
\begin{example}

Erg"anze die Abfrage aus dem Beispiel ~\ref{ex:customTable} um die Felder der Tabelle \lstinline{Album}.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={\lstinline{JOIN} mit berechneter Tabelle}]
SELECT * 
FROM Album a INNER JOIN
  (SELECT AlbumFk
    'In Library' AS Status, 
    LOWER(t.Name) as Trackname, 
    t.DurationSeconds/60 AS DurationMinutes
  FROM Track t) t2
  ON t2.AlbumFk = a.AlbumKey
\end{lstlisting}
\end{example}
Wenn man mit vielen Unterabfragen arbeitet, kann man sehr schnell die "Ubersicht "uber die verschiedenen Tabellennamen, bzw. Spaltennamen zu
verlieren. Daher empfiehlt es sich dann, selbsterkl"arende Namen einzuf"uhren.    
\section{Zusammenfassung}
\begin{itemize}
\item Wir k"onnen nach Zugeh"origkeit einer Menge mittels \lstinline{IN} filtern.
\item Wir wissen, wie wir eine Unterabfrage in ein \lstinline{IN} verpacken k"onnen.
\item Wir wissen, was \lstinline{INNER JOIN} und \lstinline{OUTER JOIN} macht, und k"onnen diese Befehle anwenden.
 \end{itemize}
\section{Kapiteltest}
\begin{exercise}
Erstelle eine Abfrage, welche den Namen jedes Kunden und den Namen seines Lieblingsbier anzeigt. Dabei sollen auch Kunden angezeigt werden,
welche kein Lieblingsbier haben.
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche den Namen jedes Kunden und den Namen seines Lieblingsbier anzeigt. Dabei sollen auch Kunden angezeigt werden,
welche kein Lieblingsbier haben. Ausserdem sollen auch gleich die Biere, welche von keinem Kunden favorisiert werden, ausgegeben werden
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche f"ur jeden Eintrag in der Tabelle BestellteBier den Kundennamen, den Biernamen und das Datum retourniert.
\end{exercise}
\chapter{Aggregierung von Daten}
Alle Datenbankabfragen, welche wir bisher abgesetzt haben, lieferten Rohdaten zur"uck. Manchmal reicht es jedoch, Statistiken "uber die Daten zu
sehen. Beispielsweise m"ochte man nur die Anzahl Buchungen pro Service sehen, oder man m"ochte nur die Gesamt"lange der Alben
wissen. Um dies zu tun, gruppiert man die Eintr"age nach gewissen Spalten. Die Datenbankengine fasst dann s"amtliche
Zeilen, welche die gleichen Gruppierungsfelder haben, in eine Zeile zusammen. Dabei werden Spalten, nach welchen nicht gruppiert werden, mit
einer Aggregierungsfunktion zusammengetragen. Wir lernen am Anfang dieses Kapitel damit, die wichtigsten Aggregierungsfunktionen einzusetzen.
Anschliessend betrachten wir, wie wir Aggregierte Tabellen mit anderen Tabellen verbinden k"onnen. Schliesslich sehen wir noch, wie wir auch "uber
aggregierte Tabellenfelder filtern k"onnen. 

\section{Aggregierungsfunktionen}
Der zur Aggregation geh"orige Aggregierungsbefehl nennt sich \lstinline{GROUP BY}. 
 mit dem \lstinline{GROUP BY}-Befehl. Jede Spalte des Resultats muss bei einer \lstinline{GROUP BY}-Abfrage entweder ein Gruppierungsfeld oder
eine Aggregationsfunktion sein. M"ogliche Aggregierungsfunktionen sind: 
\begin{itemize}
\item \lstinline{COUNT(*)}, gibt die Anzahl zusammengefassten Datens"atze zur"uck
\item \lstinline{MAX(field)} und \lstinline{MIN(field)}, retourniert den maximalen, bzw. minimalen Wert einer Spalte
\item \lstinline{AVG(field)}, retourniert den Durchschnitt einer Spalte
\end{itemize}
\begin{example}
Zeige die Anzahl der Buchungen pro Service an. Zeige f"ur jeden Service den Key an.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Z"ahlen der Buchungen pro Service}] 
SELECT ServiceFk, COUNT(*)
FROM Booking
GROUP BY ServiceFk
\end{lstlisting}
\end{example}
\begin{exercise}
\label{ex:groupBy1}
Erstelle eine Abfrage, welche in der Tabelle Tracks die AlbumFk und die Gesamtl"ange des Albums auflistet.
\end{exercise}
\section{\lstinline{GROUP BY} mit \lstinline{JOINS}}
Die letzte Abfrage w"are viel sch"oner, wenn wir gleich den Servicenamen dazu nehmen w"urden. Dies k"onnen wir mit \lstinline{JOIN} zusammenf"ugen.
Die Abfrage sieht etwa so aus:
\begin{example}
Zeige die Anzahl der Buchungen f"ur jeden Service, welcher gebucht wurde, an. Zeige fr jeden Service den Namen an
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Versuch, GROUP BY mit JOIN zu kombinieren.}] 
SELECT ?, COUNT(*)
FROM Booking b LEFT JOIN Service s
	ON s.ServiceKey = b. ServiceFk
GROUP BY b.ServiceFk
\end{lstlisting}
Jetzt stellt sich die Frage, was beim Fragezeichen stehen sollte. Da s.Name noch kein Gruppierungsfeld ist, m"usste es aggregiert werden.
Es gibt hier 3 M"oglichkeiten, weiterzufahren. Alle M"oglichkeiten f"uhren zum Ziel, doch die letzte ist zu bevorzugen. 
\begin{enumerate}
\item Wir verwenden einfach eine Aggregierung, welche etwas Sinnvolles zur"uckliefert, wie zum Beispiel \lstinline{MAX(s.Name)}. Dies funktioniert,
da Zeichenketten in SQL auch geordnet werden k"onnen, und das Maximum von gleichen Werten den gleichen Wert hat. Dennoch ist diese
L"osung eher ein Hack, der f"ur Nichteingeweihte schwer verst"andlich ist.
\item Wir gruppieren einfach auch nach \lstinline{s.Name}. Auch diese L"osung funktioniert einwandfrei. Da alle Eintr"age mit dem gleichen \lstinline{ServiceFk}
den gleichen Servicenamen haben, macht diese zus"atzliche Gruppierung nichts Sichtbares. Diese L"osung macht jedoch in den meisten
Datenbankengines die Abfrage ineffizient, und ist auch unsch"on, da nach so wenig Felder wie m"oglich gruppiert werden soll.
\item Wir gruppieren in einer Unterabfrage. In einer Unterabfrage erstellen wir eine Zwischentabelle \lstinline{bookingByService}, welche die \lstinline{ServiceFk}s
und die Anzahl als Spalten hat, dann Joinen wir diese Tabelle mit der \lstinline{Booking}-Tabelle. Dies sieht zwar auf den ersten Blick komplizierter aus, 
ist jedoch viel eleganter und klarer. Die Abfrage sieht dann so aus:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={\lstinline{JOIN} mit gruppierter Tabelle}] 
SELECT s.Name, BookingCount
FROM Service s LEFT JOIN 
  (SELECT ServiceFk, COUNT(*) AS BookingCount
  FROM Booking
  GROUP BY ServiceFk) bookingByService
  ON bookingByService.ServiceFk = s.ServiceKey
\end{lstlisting}
Eine kleine Anmerkung: Diese Technik muss nur dann angewendet werden, wenn die Aggregation eigentlich nur "uber eine Tabelle stattfindet.
Es gibt F"alle, in welchen Daten aus mehreren Tabellen zusammengerechnet und dann aggregiert werden. Dann braucht man diese Technik nicht. 
\end{enumerate}
\end{example} 
\begin{exercise}
Erweitere die Abfrage aus Aufgabe~\ref{ex:groupBy1}, so dass der K"unstlername und der Albumname neben der Gesamtspieldauer des Albums steht.
\end{exercise}
\section{Filtern bei Gruppierungen}
Bei einer Gruppierungsabfrage kann man wie gewohnt mit einer \lstinline{WHERE}-Klausel "uber die Datens"atze filtern. Diese Filterung geschieht dann vor der
Aggregation. 
\begin{example}Zeige die Anzahl Buchungen ab dem 24. November f"ur jeden Service, der in dieser Zeit gebucht wurde, an. Zeige f"ur jeden Service den Key an.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Filtern vor Gruppierung}] 
SELECT ServiceFk, COUNT(*)
FROM Booking
WHERE StartDate > '2014-11-24'
GROUP BY ServiceFk
\end{lstlisting}
\end{example}
Es gibt jedoch auch die M"oglichkeit, "uber Aggregationen zu filtern. Dies geschieht mit der \lstinline{HAVING}-Klausel. Diese zus"atzliche Filterung steht 
nach der \lstinline{GROUP BY}-Klausel.

\begin{example}
Suche die Schl"ussel aller Services, welche ab dem 24. November genau ein mal gebucht wurden:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Filtern vor und nach Gruppierung}] 
SELECT ServiceFk
FROM Booking
WHERE StartDate > '2014-11-24'
GROUP BY ServiceFk
HAVING COUNT(*) = 1
\end{lstlisting}
Wir sehen, dass die Aggregation, welche in der \lstinline{HAVING}-Klausel erw"ahnt wird, gar nicht in der \lstinline{SELECT}-Klausel vorkommt. 
Wie wir in der n"achsten "Ubung sehen werden, k"onnen in \lstinline{HAVING}-Klausel und in der \lstinline{SELECT}-Klausel v"ollig verschiedene
Aggregationen vorkommen. 
\end{example}

\begin{exercise}
Erstelle eine Abfrage, welche die Gesamtdauer der Alben, bei welchen die Durchschnittsdauer der Tracks weniger als 3 Minuten betr"agt, berechnet.
\end{exercise} 
\begin{exercise}
Gebe bei den folgenden Bedingungen an, ob eine \lstinline{WHERE} oder eine \lstinline{HAVING}-Klausel gebraucht wird. Die Abfrage muss nicht erstellt werden.
\begin{itemize}
\item Finde die Anzahl Buchungen aller Kunden, welche schon mindestens zwei Buchungen get"atigt haben.
\item Finde die Anzahl Buchungen des ``T"onen''-Services aller Kunden.
\item Finde die Alben, welche mehr als 10 Tracks haben.
\item Finde die durchschnittliche Dauer der ersten f"unf Tracks jedes Albums.
\end{itemize} 
\end{exercise}
\begin{exercise}
Ein Bonustrack in einem Album ein Track, deren TrackId gr"osser ist als die Anzahl Tracks des Albums. In unserem
Beispiel sind Rockaway Beach und Otherside Bonustracks, da in unserem unvollst"andigen Beispiel Album 2 nur ein Track hat, bzw. Album 2 nur
zwei Tracks hat. Erstelle eine Abfrage, welche die Alben-Ids aller Alben mit Bonustracks zur"uckgibt.
\end{exercise}
\section{Zusammenfassung}
\begin{itemize}
\item Wir kennen die wichtigsten Aggregierungsfunktionen.
\item Wir wissen, wie man das \lstinline{GROUP BY} "uber eine Tabelle einsetzt.
\item Wir wissen, wie man das \lstinline{GROUP BY} "uber mehrere Tabellen einsetzt, und wie man die Probleme vermeiden kann, welche dabei
auftreten k"onnen.
\item Wir wissen, wie wir bei Gruppierungsabfragen vor der Gruppierung, und wie wir nach der Gruppierung filtern k"onnen.
 \end{itemize}

\section{Kapiteltest}
\begin{exercise}
Erstelle eine Abfrage, welche zur"uckgibt, welcher Kunde wieviel Bestellungen get"atigt hat.
\end{exercise}
Wieder arbeiten wir mit der Datenbank aus Tabellen~\ref{tbl:testStart} bis~\ref{tbl:testEnd}.
\begin{exercise}
Erstelle eine Abfrage, welche bei jeder Bestellung KundenId, BarId und Gesamtpreis zur"uckgibt.
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche f"ur jede BarId, welche von Bestellungen referenziert wird, den Umsatz f"ur die Silvesternacht 
(31.12.2014 18:00 bis 1.1.2015 06:00) zur"uckgibt.
\end{exercise}
\begin{exercise}
Zeige die Namen der Personen an, welche in der Silvesternacht mehr als 20 Franken f"ur Bier ausgegeben haben.
\end{exercise}
\begin{exercise}
Erstelle eine Abfrage, welche den Biernamen und dessen g"unstigsten Verkaufspreis zur"uckgibt. Tipp: Die Abfrage muss ber"ucksichtigen, ob das
Bier im Sortiment als gel"oscht markiert wurde.
\end{exercise}
\chapter{L"osungen}
\section{Kapitel 1}
\begin{enumerate}
\item Wenn die \lstinline{ServiceFk} sich "andert, wird ein anderer Service referenziert. Der Service 2 dauert 15 Minuten l"anger als der Service 1, und beinhaltet auch das 
F"onen nach dem Haarschnitt.
\item Der Prim"arschl"ussel ist ein eindeutiges Merkmal einer Zeile. Wenn wir ServiceId und CustomerId als zusammengesetzten Prim"arschl"ussel 
verwenden w"urden, d"urfte f"ur ein Kunde ein Service nur genau ein Mal im System erfasst sein. Dies heisst also, dass ein Kunde nicht mehrere Termine
f"ur einen Service gleichzeitig haben kann. Sogar wenn dies akzeptabel w"are, gibt es jedoch einen anderen Grund, welcher dagegen spricht: Beim n"achsten
Termin des gleichen Typs m"usste man in der Datenbank die alte Buchung "uberschreiben. Somit w"aren die historischen Daten unbrauchbar.  
\item Obwohl es in einer Musiksammlung vorkommen kann, dass das Album bei gewissen Tracks nicht bekannt sind, wird dies in dieser Datenbank keine
Rechnung getragen. Die Spalte AlbumFk ist Teil des Prim"arschl"ussels, und darf somit nicht fakultativ sein, also keine NULL-eintr"age enthalten.
\item 
\begin{itemize}
\item Am 31.12. um 22 Uhr hat Urs in der Vollmond Taverne 2 Brandl"oscher bestellt.
\item Um 23 Uhr 23 hat Lisa auch in der Vollmond Taverne 2 Brand"oscher und ein Qu"ollfrisch bestellt.
\item Gleich danach hat Lisa am gleichen Ort noch ein Sprint bestellt.
\item Um 23 Uhr 52 hat Heinz im Si o No 3 Sprint und ein W"adi-Br"au Blond Premium bestellt.
\item Am Neujahrstag um 1 Uhr 21 hat Andrea in der Brasserie Federal 3 Qu"ollfrisch und ein Heineken Lager bestellt.
\end{itemize}
\item Das Vollmond-Bier kostet im Einkauf 1.30 Franken, und wird in der Vollmond Taverne zu 4 Franken ausgeschenkt. Also wird das Bier zu etwas mehr als
3 mal dem Einkaufspreis verkauft.
\item In die Tabellen \lstinline{Bestellung} und \lstinline{BestellteBier} werden folgende Zeilen eingef"ugt:
\begin{table}[H]
         \begin{tabular}{|llll|}
    \hline
    {\lstinline!BestellungId!} & {\lstinline!KundenId!} &  {\lstinline!BarId!} &  {\lstinline!Zeit!}        \\ 
       (PK) &(FK(Kunde.KundenId)) & (FK(Bar.BarId)) &\\ \hline
    6 &2                  & 3 & 1.1.2015 02:00\\
   
    
     \hline
    \end{tabular}
    \caption {Bestellung}
         \begin{tabular}{|lll|}
    \hline
     {\lstinline!BestellungFk!} & {\lstinline!SortimentFk!} &  {\lstinline!Anzahl!}        \\ 
       (PK, FK(Bestellung.& (PK, FK(Sortiment. & \\ 
              BestellungId)) &SortimentId)) & \\ \hline
    6&14&2\\
    
     \hline
    \end{tabular}
    \caption{BestellteBier}
\end{table}
\item Wenn der Schl"ussel zusammengesetzt w"are, w"urde eine Bar pro Bier genau einen Preis haben. Auf den ersten Blick macht das Sinn, jedoch nicht
in Kombination mit der Delete-Spalte. Die Delete-Spalte erm"oglicht es uns, den Preis jedes bestellten Bieres nachzuvollziehen. Diese M"oglichkeit geht jedoch
verloren, wenn wir nur einen Preis pro Bier und Bar speichern k"onnen.
\item Eine Spalte \lstinline{BestellteBierId} k"onnte man einf"uhren und als alleiniger Prim"arschl"ussel w"ahlen. Die Datenbank w"urde jedoch eine sinnvolle
Einschi"ankung verlieren. Pro Bestellung k"onnte es n"amlich mehrere Eintr"age mit dem gleichen Bier, bzw. dem gleichen Eintrag im Sortiment geben. Das
kann gewisse Berechnungen etwas komplexer machen, w"urde jedoch der Funktionalit"at der Datenbank nicht schaden. 
\end{enumerate}
\section{Kapitel 2}
\begin{enumerate}
\item Es macht durchaus Sinn, wenn man die L"ange einer Zeichenkette einschr"ankt. Einerseits, weil andere L"angen keinen Sinn ergeben. Beispielsweise
haben die Kantonsk"urzel (z.b. ZH, ZG, SG, etc.) immer genau zwei Buchstaben. Auch gibt es Daten, welche nicht l"anger als eine gewisse Anzahl Zeichen haben kann.
Zum Beispiel gibt es weltweit keine Ortsnamen, welche l"anger als 150 Zeichen lang sind. Daher kann man, um die Qualit"at der Daten zu gew"ahrleisten, die L"ange eines
Ortsnamenfeldes auf 150 Zeichen (etwas mehr, falls man f"ur noch nicht existierende Ortsnamen gewappnet sein m"ochte) zu beschr"anken.
\item In der pr"asentierten L"osung sind die Zeichenkettenl"angen frei gew"ahlt. Abweichungen in den L"angen k"onnen durchaus vorkommen. 
Auch sind andere Formate f"ur die Zeitdauerwerte vorstellbar.
\begin{itemize}
\item Customer:\\
	CustomerId INT \\
	FirstName VARCHAR(200)\\
	LastName VARCHAR(200)\\
	Email VARCHAR(300)
\item Service:\\
	ServiceId INT \\
	Name VARCHAR(1000)\\
	DurationMinutes INT
\item Booking:\\
	BookingId INT \\
	ServiceFk INT\\
	CustomerFk INT\\
	StartDate DATETIME	
\end{itemize} 
\item \begin{itemize}
\item Album:\\
	AlbumId INT \\
	ArtistName VARCHAR(1000)\\
	AlbumName VARCHAR(1000)\\
	GenreFk INT
\item Track:\\
	AlbumFK INT \\
	TrackId INT\\
	Name VARCHAR(1000)\\
	DurationSeconds INT
\item Genre:\\
	GenreId INT \\
	ParentGenreFk INT\\
	Name VARCHAR(1000)	
\end{itemize}
\item Bei vielen Zeilen steht es uns frei, ob sie \lstinline{NULL} sein d"urfen oder nicht.  
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle Album}]  
CREATE TABLE Album (
  AlbumId INT NOT NULL,
  ArtistName VARCHAR(200),
  AlbumName VARCHAR(200),
  GenreFk INT,
  CONSTRAINT pk_album PRIMARY KEY 
    (AlbumId),
  CONSTRAINT fk_album_genre FOREIGN KEY 
    (GenreFk)
    REFERENCES Genre(GenreId)
);
\end{lstlisting}
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle Genre}]  
CREATE TABLE Genre (
  GenreId INT NOT NULL,
  ParentGenreFk INT,
  Name VARCHAR(1000),
  CONSTRAINT pk_genre PRIMARY KEY 
    (GenreId),
  CONSTRAINT fk_genre_genre FOREIGN KEY 
    (ParentGenreFk)
    REFERENCES Genre(GenreId)
);
\end{lstlisting}
\item Bei vielen Zeilen steht es uns frei, ob sie NULL sein d"urfen oder nicht.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle Album}]  
CREATE TABLE Customer (
	CustomerId INT NOT NULL,
	FirstName VARCHAR(200),
	LastName VARCHAR(200),
	Email VARCHAR(300),
	CONSTRAINT pk_customer PRIMARY KEY 
		(CustomerId)
		
);
\end{lstlisting}
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle Genre}]  
CREATE TABLE Service (
	ServiceId INT NOT NULL,
	Name VARCHAR(1000),
	DurationMinutes INT NOT NULL,
	CONSTRAINT pk_service PRIMARY KEY 
		(ServiceId)
);
\end{lstlisting}
\item  Erstellen der Beispieldaten:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Beispielsdaten}]  
INSERT INTO Genre (GenreId, ParentGenreId, Name)
VALUES (1, NULL, 'Rock'),
  (2, 1, 'Punk Rock'),
  (3, NULL, 'Hip-Hop')
  
INSERT INTO Album
        (AlbumKey, ArtistName, AlbumName, GenreFk)
VALUES 
  (1, 'Red Hot Chilli Peppers', 
    'Californication', 1),
  (2, 'The Ramones', 'Rocket To Russia', 2),
  (3, 'The Beastie Boys', 'Ill Communication', 3)
  
INSERT INTO Track
        (AlbumFk, TrackId, Name, DurationSeconds)
VALUES (3, 1, 'Sure Shot', 200),
  (1, 1, 'Around the World', 239),
  (2, 2, 'Rockaway Beach', 127),
  (1, 4, 'Otherside', 255)
\end{lstlisting}
\item So werden die Tabellen erstellt.
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erstellen der Tabelle Bestellung und BestellteBier}]  
CREATE TABLE Bestellung (
  BestellungId INT NOT NULL,
  KundenFk INT NOT NULL,
  BarFk INT NOT NULL,
  Zeit DATETIME,
  CONSTRAINT pk_bestellung PRIMARY KEY
    (BestellungId),
  CONSTRAINT fk_bestellung_kunde FOREIGN KEY
    (KundenFk)
    REFERENCES Kunde(KundenId),
  CONSTRAINT fk_bestellung_bar FOREIGN KEY(BarFk)
    REFERENCES Bar(BarId)
);
CREATE TABLE BestellteBier (
  BestellungFk INT NOT NULL,
  SortimentFk INT NOT NULL,
  Anzahl INT NOT NULL,
  CONSTRAINT pk_bestellte_bier PRIMARY KEY
    (BestellungFk, SortimentFk),
  CONSTRAINT fk_bestellteBier_bestellung 
    FOREIGN KEY (BestellungFk)
    REFERENCES  Bestellung(BestellungId),
  CONSTRAINT fk_bestellteBier_sortiment
    FOREIGN KEY (SortimentFk)
    REFERENCES Sortiment(SortimentId)
);
\end{lstlisting}
\item Die Daten werden wie folgt eingef"ugt:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Einf"ugen der Bestellung}]  
INSERT INTO Bestellung
  (BestellungId, KundenId, BarId, Zeit)
 VALUES (6, 2, 3, '2015-1-1 02:00')
INSERT INTO BestellteBier
  (BestellungFk, SortimentFk, Anzahl)
VALUES (6, 14, 2)
\end{lstlisting}

\end{enumerate}




\section{Kapitel 3}
\begin{enumerate}
\item Die Abfrage sieht wie folgt aus:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Abfrage zu Tabelle~\ref{tbl:exbySolution}}]  
SELECT LOWER(Name) AS NameLower,
  DurationMinutes*60*1000 AS DurationMilliseconds
FROM Service
\end{lstlisting}
\item Buchungen sortiert:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Buchungen sortiert}]  
SELECT *
FROM Booking
ORDER BY StartDate DESC
\end{lstlisting}
\item Alben sortiert:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Alben sortiert}]  
SELECT *
FROM Album
ORDER BY GenreFk, ArtistName DESC
\end{lstlisting}
\item Termine gefiltert:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Termine gefiltert}]  
SELECT *
FROM Booking
WHERE BookingStart > '2014-11-24' 
  AND BookingStart < '2014-12-01'
\end{lstlisting}
\item Tabelle Bar:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Tabelle Bar}]  
SELECT *
FROM Bar
\end{lstlisting}

\item Tabelle Bier:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Bier}]  
SELECT 
  LOWER(Name) AS NameLower,
  Deziliter * 100 AS Milliliter,
  Einkaufpreis / 1.2 as EinkaufpreisEuro
FROM Bier
\end{lstlisting}

\item Flaschengr"ossen:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Flaschengr"ossen}]  
SELECT DISTINCT Deziliter
FROM Bier
\end{lstlisting}
\item Preise des Biers:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Preis von Bier 7}]  
SELECT Preis
FROM Sortiment
WHERE BierFk = 7
\end{lstlisting}
\item Sortiment nach Bier:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Sortiment nach Bier}]  
SELECT *
FROM Sortiment
ORDER BY BierFk
\end{lstlisting}
\item Bier mit Umlaut:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Bier mit Umlaut}, escapechar=\$]  
SELECT *
FROM Bier
WHERE Name LIKE '%$"a$%'
  OR Name LIKE '%$"o$%'
  OR Name LIKE '%$"u$%'
\end{lstlisting}
\item Biere der Brauerei 1:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Biere der Brauerei 1}, escapechar=\$]  
SELECT *
FROM Bier
WHERE BrauereiFk = 1
\end{lstlisting}
\item G"unstige Biere:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={G"unstige Biere}, escapechar=\$]  
SELECT *
FROM Bier
WHERE Einkaufspreis / Deziliter < 0.40
\end{lstlisting}
\end{enumerate}
\section{Kapitel 4}

\begin{enumerate}
\item Termine, welche l"anger als 30 Minuten dauern:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Termine, welche l"anger als 30 Minuten dauern}]  
SELECT *
FROM Booking
WHERE ServiceFk IN (
  SELECT ServiceId
  FROM Service
  WHERE DurationMinutes > 30
)
\end{lstlisting}
\item Erweiterte Tabelle:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erweiterte Tabelle}]  
SELECT c.FirstName, c.LastName, s.Name, 
 b.StartDate, DATEADD(minute, s.DurationMinutes, 
    b.StartDate) AS EndDate
FROM Customer c 
  INNER JOIN Booking b 
    ON b.CustomerFk = c.CustomerId
  INNER JOIN Service s 
    ON b.ServiceFk = s.ServiceId
\end{lstlisting}
\item Selbst-JOIN:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Erweiterte Tabelle}]  
SELECT g1.Name AS SubGenreName, 
  g2.Name AS ParentGenreName
FROM Genre g1
  INNER JOIN Genre g2
    ON g1.ParentGenreFk = g2.GenreId
\end{lstlisting}
\item Die vier Tabellen sehen wie folgt aus:
\begin{table}[H]
         \begin{tabular}{|ll|}
    \hline
    {\lstinline!SubGenreName!} & {\lstinline!GenreName!}     \\ \hline
    Punk Rock & Rock\\    
     \hline
    \end{tabular}
    \caption {INNER JOIN}
        \begin{tabular}{|ll|}
    \hline
    {\lstinline!SubGenreName!} & {\lstinline!GenreName!}     \\ \hline
    Rock & NULL\\
    Punk Rock & Rock\\
    Hip-Hop & NULL\\    
     \hline
    \end{tabular}
    \caption {LEFT JOIN}
          \begin{tabular}{|ll|}
    \hline
    {\lstinline!SubGenreName!} & {\lstinline!GenreName!}     \\ \hline
    Punk Rock & Rock\\
    NULL & Punk Rock\\
    NULL & Hip-Hop\\    
     \hline
    \end{tabular}
    \caption {RIGHT JOIN}
          \begin{tabular}{|ll|}
    \hline
    {\lstinline!SubGenreName!} & {\lstinline!GenreName!}     \\ \hline
    Rock & NULL\\
    Hip-Hop & NULL\\  
    Punk Rock & Rock\\
    NULL & Punk Rock\\
    NULL & Hip-Hop\\
     \hline
    \end{tabular}
    \caption {FULL OUTER JOIN}    
\end{table}

\item Kunde mit Lieblingsbier:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Kunde mit Lieblingsbier}, escapechar=\$]  
SELECT k.Name, b.Name
FROM Kunde k LEFT JOIN Bier b 
  ON k.LieblingsbierFk = b.BierId
\end{lstlisting}
\item Kunde mit Lieblingsbier sowie unfavorisierte Biere:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Kunde mit Lieblingsbier sowie unfavorisierte Biere}, escapechar=\$]  
SELECT k.Name, b.Name
FROM Kunde k FULL OUTER JOIN Bier b 
  ON k.LieblingsbierFk = b.BierId
\end{lstlisting}
\item Bestellte Bier in lesbarer Form:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Bestellte Bier in lesbarer Form}, escapechar=\$]  
select k.Name, bi.Name, b.Zeit
FROM BestellteBier bb
  INNER JOIN Bestellung b 
    ON bb.BestellungFk = b.BestellungId
  INNER JOIN Kunde k
    ON  b.KundenFk = k.KundenId
  INNER JOIN Sortiment s
    ON bb.SortimentFk = s.SortimentId
  INNER JOIN Bier bi
    ON s.BierFk = bi.BierId
\end{lstlisting}

\end{enumerate}
\section{Kapitel 5}
\begin{enumerate}
\item Aggregierte Albuml"ange:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Albuml"ange}]  
SELECT AlbumFk, 
  SUM(DurationMinutes) AS AlbumLength
FROM Tracks
GROUP BY AlbumFk
\end{lstlisting}
\item Mit Albumnamen:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Albuml"ange mit Albumnamen}]  
SELECT a.ArtistName, a.AlbumName, 
  albumLengths.AlbumLength
FROM Album a INNER JOIN
  ( SELECT AlbumFk, 
      SUM(DurationMinutes) AS AlbumLength
    FROM Tracks
    GROUP BY AlbumFk) albumLengths
  ON a.ArtistId = albumLengths.ArtistFk
\end{lstlisting}
\item HAVING-Filter:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Albuml"ange mit HAVING-Filter}]  
SELECT AlbumFk, 
   SUM(DurationMinutes) AS AlbumLength
FROM Tracks
GROUP BY AlbumFk
HAVING AVG(DurationMinutes) < 180
\end{lstlisting}
\item Zur Repetition: Eine WHERE-Klausel ist ein Filter f"ur die Daten vor der Aggregation. Die HAVING-Klausel
filtert Daten, nachdem sie aggregiert wurden.
\begin{itemize}
\item Die Anzahl Buchungen ist ein aggregierter Wert. Daher steht diese Bedingung in der HAVING-Klausel.
\item Nach Service muss vor der Aggregation, also im WHERE-Teil gefiltert werden.
\item HAVING-Klausel
\item WHERE-Klausel. Zuerst suchen wir die ersten f"unf Tracks des Albums heraus. Der Durchschnitt wird
anschliessend berechnet.
\end{itemize}
\item Bonustrack-Abfrage:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Bonustrack-Abfrage}]  
SELECT AlbumFk
FROM Tracks
GROUP BY AlbumFk
HAVING COUNT(*) < MAX(TrackId)
\end{lstlisting}

\item Bestellungen pro Kunde:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Bestellungen pro Kunde}]  
SELECT b.KundenFk, COUNT(*)
FROM Bestellung
GROUP BY KundenFk
\end{lstlisting}

\item Diese Abfrage ist etwas komplizierter. Hier Joinen wir mit einer Unterabfrage. Die Unterabfrage gruppiert die Bestellungen nach Gesamtpreis. 
Dazu m"ussen zwei Spalten aus zwei verschiedenen Tabellen zusammen verrechnet und dann aggregiert werden. Dies ist ohne weitere
Unterabfrage m"oglich.

Die ussere Abfrage sammelt weitere Informationen zur Bestellung.

\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Bestellungen}, escapechar=\$]  
SELECT b.KundenFk, b.BarFk, bbGrouped.TotalPrice
FROM Bestellung b INNER JOIN
  (SELECT bb.BestellungFk, 
    SUM(bb.Anzahl * s.Preis) AS TotalPrice
  FROM BestellteBier bb
    INNER JOIN Sortiment s
      ON s.SortimentId = bb.SortimentFk
  GROUP BY bb.BestellungFK
  ) bbGrouped
  ON bbGrouped.BestellungFk = b.BestellungId
\end{lstlisting}
\item Wir entdecken, das wir die letzte Aufgabe gr"ostenteils wiederverwenden k"onnen. Die Abfrage wird nun noch etwas komplizierter:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Umsatz pro Bar}, escapechar=\$]  
SELECT b.BarFk, 
  SUM(bbGrouped.TotalPrice) AS Neujahrsumsatz
FROM Bestellung b INNER JOIN
  (SELECT bb.BestellungFk, 
    SUM(bb.Anzahl * s.Preis) AS TotalPrice
  FROM BestellteBier bb
    INNER JOIN Sortiment s
      ON s.SortimentId = bb.SortimentFk
  GROUP BY bb.BestellungFK
  ) bbGrouped
  ON bbGrouped.BestellungFk = b.BestellungId
WHERE b.Zeit > '2014-31-12 18:00' 
  AND b.Zeit < '2015-01-01 06:00'
GROUP BY b.BarFK
\end{lstlisting}

\item Und wieder k"onnen wir die vorhergehende Abfrage wiederverwenden:
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={Trinkfreudige Kunden}, escapechar=\$]  
SELECT k.Name
FROM Kunde k
INNER JOIN
( SELECT b.KundenFk, 
    SUM(bbGrouped.TotalPrice) AS Neujahrsausgaben
  FROM Bestellung b INNER JOIN
    (SELECT bb.BestellungFk, 
      SUM(bb.Anzahl * s.Preis) AS TotalPrice
    FROM BestellteBier bb
      INNER JOIN Sortiment s
        ON s.SortimentId = bb.SortimentFk
    GROUP BY bb.BestellungFk
    ) bbGrouped
  ON bbGrouped.BestellungFk = b.BestellungId
  WHERE b.Zeit > '2014-31-12 18:00' 
    AND b.Zeit < '2015-01-01 06:00'
  GROUP BY b.KundenFk) ka
ON ka.KundenFk = k.KundenId
WHERE ka.Neujahrsausgaben > 20
\end{lstlisting}
\item Dies ist wieder ein einfacher JOIN mit einem GROUP BY
\begin{lstlisting}[frame=single, language=SQL, style=SQL, caption={G"unstigster Preis}, escapechar=\$]
SELECT b.Name, billigBier.BilligPreis
FROM Bier b
INNER JOIN
  (SELECT BierFk, MIN(Preis) AS BilligPreis
  FROM Sortiment
  WHERE Deleted = 0
  GROUP BY BierFk) billigBier
  ON billigBier.BierFk = b.BierId
\end{lstlisting}
\end{enumerate}
\end{document}
